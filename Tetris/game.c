
#ifndef __GAME_C__
#define __GAME_C__

#include "game.h"
#include "globals.h"

// function shows next tetromino
void show_next()
{
	switch (next) // в зависимости от следующей фигуры
	{
	case 0:
		memcpy(left[11] + WIDTH - 10, TetrominoI[1] + 8, 8); // меняем в массиве ячейки на рисунок соответствующей фигуры
		return;
	case 1:
		memcpy(left[10] + WIDTH - 8, TetrominoJ[0] + 8, 2);
		memcpy(left[11] + WIDTH - 8, TetrominoJ[1] + 8, 6);
		return;
	case 2:
		memcpy(left[10] + WIDTH - 4, TetrominoL[0] + 12, 2);
		memcpy(left[11] + WIDTH - 8, TetrominoL[1] + 8, 6);
		return;
	case 3:
		memcpy(left[10] + WIDTH - 6, TetrominoO[0] + 10, 4);
		memcpy(left[11] + WIDTH - 6, TetrominoO[1] + 10, 4);
		return;
	case 4:
		memcpy(left[10] + WIDTH - 6, TetrominoS[0] + 10, 4);
		memcpy(left[11] + WIDTH - 8, TetrominoS[1] + 8, 4);
		return;
	case 5:
		memcpy(left[10] + WIDTH - 6, TetrominoT[0] + 10, 2);
		memcpy(left[11] + WIDTH - 8, TetrominoT[1] + 8, 6);
		return;
	case 6:
		memcpy(left[10] + WIDTH - 8, TetrominoZ[0] + 8, 4);
		memcpy(left[11] + WIDTH - 6, TetrominoZ[1] + 10, 4);
		return;
	}
}

// self explanatory, refreshes screen
void updatescrn()
{
	clear(); // очистка содержимого текущего окна и заполнения его пробелами
	printw("\n");
	for (int i = 2; i < HEIGHT; ++i) // со второй строчки начинаем вывод по всей высоте игрового экрана
	{
		if (shownext) // если флаг "показывать следующую фигуру" == 1, то добавляем в массив left изображение следующей фигуры
		{
			show_next();
		}
		printw("%s", left[i]);	 // выводим на экран левую часть игрового экрана
		printw("%s", center[i]); // выводим на экран центр игрового экрана
		if (showtext)			 // если флаг "показывать инструкцию" == 1, то добавляем в массив right текст с инструкцией
		{
			printw("%s", right[i]); // печатаем правую часть игрового экрана
		}
		printw("\n");
	}
	refresh();	  // обновления текущего содержимого окна на экране. Она принимает все изменения, сделанные с помощью функций printw(), и других, и отображает их на экране
	if (shownext) // опустошаем место изображения следующей фигуры в массиве left
	{
		memcpy(left[10] + WIDTH - 10, "        ", 8);
		memcpy(left[11] + WIDTH - 10, "        ", 8);
	}
}

// updates score number on the gamescreen (on the left part)
void updatescore()
{
	char *tmp = malloc(sizeof *tmp * 15); // // почему 15? переменная tmp становится указателем на выделенную область памяти в куче, которую можно использовать для хранения строки до 15 символов
	sprintf(tmp, "%-14d", score);		  // sprintf - string print, в "%-14d" подставляется переменная score и всё это записывается в переменную tmp."-" это выровненное по левому краю. 14  - 14ти символьное поле.
	memcpy(left[7] + 9, tmp, 14);		  // вписываем в левую часть игрового экрана в место для количества баллов значение tmp длинной в 14 символов
	free(tmp);							  // освобождаем память в куче
}

// show toplist
void toplist()
{
	char *buffer = malloc(sizeof *buffer * TOPLISTMAXLINELENGTH); // выделяем динамическую память в куче под максимальное колличество строк топлиста
	FILE *f;
	clear();																		 // очищаем экран, заполняем пробелами
	if (!(f = fopen("toplist", "r")))
	{												 // если не вышло открыть файл "топлист" для чтения
		printw("\n\n\n    Toplist doesn't exist! Your score has to be higher than 0" // пишем текст на экране
			   " to be added ;)\n");
	}
	else
	{
		printw("\n");
		while (fgets(buffer, TOPLISTMAXLINELENGTH, f) != NULL) // до тех пор пока не закончится информация в файле
		{ 
			printw("                        %s", buffer);	   // печатаем из буффера
		}
		fclose(f);											   // закрываем соединение с файлом
	}
	refresh();	  // обновления текущего содержимого окна на экране. Она принимает все изменения, сделанные с помощью функций printw(), и других, и отображает их на экране
	free(buffer); // освобождаем память
	getch();	  // ждем нажатия клавиши
}

// add score to toplist (top-20) if needed
void addscore()
{
	if (!score) // если количество баллов ноль
	{
		return; // выходим отсюда
	}
	FILE *f;
	if (!(f = fopen("toplist", "r"))) // если файл "топлист" не удалось открыть для чтения
	{
		if (!(f = fopen("toplist", "w"))) // если файл не удалось открыть для записи
		{
			exit(1); // аварийно завершаем программу
		}
		fprintf(f, "NAME          LVL SCORE        \n%-13s %2d  %-14d\n", name, level, score); // пропечатываем топлист только с нынешним игроком
		fclose(f);																			   // закрываем файл
		return;
	}
	f = fopen("toplist", "r"); // файл "топлист" удалось открыть для чтения
	int num, added = 0;
	char *buffer = malloc(sizeof *buffer * TOPLISTMAXLINELENGTH); // выделяем динамическую память в куче под максимальное колличество символов в одной строке топлиста
	FILE *tmp;
	if (!(tmp = fopen("tmp", "a+"))) // если не удалось открыть файл ТМП в режиме добавления данных в конец и для чтения данных из файла. Если файл не существует, он будет создан.Если файл существует, данные будут добавлены в конец, а позиционный указатель файла будет установлен в конец файла.
		exit(1);					 // аварийное завершение программы
	int cntr = 21;//максимальное количество строк топлиста, которое может вывести спроектированный интерфейс и которое может быть записано в файл 
	//смысл функции в том, чтобы добавить баллы текущего игрока в файл "топлист" в нужное место по рейтингу
	while (fgets(buffer, TOPLISTMAXLINELENGTH, f) != NULL && --cntr) // записываем в буффер существующий топлист, по одному игроку, до тех пор пока не закончится информация в файле и выводимые строки на экран начиная снизу
	{
		num = strtol(buffer + 18, NULL, 10);   // string to long integer, десятичная система счисления
		if (!added && score > num && num != 0) // если баллы у текущего игрока больше, чем у игроков из топлиста и у игроков из топлиста счет больше 0
		{
			fprintf(tmp, "%-13s %2d  %-14d\n", name, level, score); // записываем в файл ТМП рейтинг текущего игрока на текущей строчке
			score = 0;												// обнуляем счетчик баллов текущего игрока
		}
		fputs(buffer, tmp); // записываем содержимое bufferа в файл ТМП
	}
	if (cntr && score) // если счет текущего игрока больше нуля и он в топ-20 
	{
		fprintf(tmp, "%-13s %2d  %-14d\n", name, level, score); // записываем в конец файла ТМП рейтинг текущего игрока
	}
	fclose(f);				  // закрываем файл "топлист"
	fclose(tmp);			  // закрываем временный файл
	remove("toplist");		  // удаляем файл "топлист"
	rename("tmp", "toplist"); // переименовываем файл ТМП в топлист
	free(buffer);			  // освобождаем память, выделенную под буффер
}

// prints game over screen
int gameover()
{
	nodelay(stdscr, FALSE); // при FALSE - переходит режим, в котором getch() будет ждать нажатия клавиш
	if (!end)				// если игра НЕ закончилась
	{
		addscore(); // добавляем в файл рейтинг текущего игрока, обновляем топлист
	}
	end = 1;									 // меняем флаг окончания игры на "игра закончилась"
	memcpy(left[9], "    __      __      ___ \0" // добавляем на игровой экран надпись окончания игры
					"  /'_ `\\  /'__`\\  /' __`\0"
					" /\\ \\L\\ \\/\\ \\L\\.\\_/\\ \\/\\\0"
					" \\ \\____ \\ \\__/.\\_\\ \\_\\ \0"
					"  \\/___L\\ \\/__/\\/_/\\/_/\\\0"
					"    /\\____/             \0"
					"    \\_/__/              \0",
		   WIDTH * 7);
	memcpy(center[9], "___      __         ___ \0"
					  " __`\\  /'__`\\      / __`\0"
					  " \\/\\ \\/\\  __/     /\\ \\L\\\0"
					  "\\_\\ \\_\\ \\____\\    \\ \\___\0"
					  "/_/\\/_/\\/____/     \\/___\0",
		   WIDTH * 5);
	memcpy(right[9], "  __  __    __  _ __    \0"
					 "\\/\\ \\/\\ \\ /'__`/\\`'__\\  \0"
					 " \\ \\ \\_/ /\\  __\\ \\ \\/   \0"
					 "_/\\ \\___/\\ \\____\\ \\_\\   \0"
					 "/  \\/__/  \\/____/\\/_/   \0",
		   WIDTH * 5);
	memcpy(center[16], "    : QUIT    : RESET   \0"
					   "        : TOPLIST       \0",
		   WIDTH * 2);
	center[16][3] = toupper(EXT);	// выводим актуальную кнопку управления для выхода
	center[16][13] = toupper(RSET); // выводим актуальную кнопку управления для "начать заново"
	center[17][7] = toupper(TPLS);	// выводим актуальную кнопку управления для вывода топлиста
	clear();						// очищаем экран
	printw("\n");
	for (int i = 2; i < HEIGHT; ++i)
	{
		if (i == 9 || i == 15 || i == 16)
		{
			attron(COLOR_PAIR(2)); // меняем цвет текста на вторую пару цветов (красный)
		}
		else if (i == 18)
		{
			attron(COLOR_PAIR(1)); // меняем цвет текста на первую  пару цветов (зеленый)
		}
		printw("%s", left[i]);	   // печатаем левую часть игрового экрана
		if (i == 14 || i == 15)
		{
			attron(COLOR_PAIR(1)); // меняем цвет текста на первую  пару цветов (зеленый)
		}
		printw("%s", center[i]);   // печатаем центральную часть игрового экрана
		printw("%s\n", right[i]);  // печатаем правую часть игрового экрана
	}
	refresh(); // обновления текущего содержимого окна на экране. Она принимает все изменения, сделанные с помощью функций printw(), и других, и отображает их на экране
	return 1;
}

// check if a line should be cleared
void checkclr()
{
	int cleared = 0;
	if (fixedpoint[0] > 2)
	{
		for (int i = -2; i < 2; ++i)
		{
			if (!strncmp(center[fixedpoint[0] + i] + 3, "][][][][][][][][][", 18))//если ситуация на игровом єкране такая же как и "][][][][][][][][]["
			{
				++cleared;
				for (int j = fixedpoint[0] + i; j > 0; --j)
				{
					memcpy(center[j] + 2, center[j - 1] + 2, 20);//очищаем строку игрового экрана от ][][ 
				}
			}
		}
		if (cleared)//если произошла очистка строки
		{
			score += SCORE;//добавляем баллы
			score += dropped;//добавляем бонусные баллы
			dropped = 0;//обнуляем
			updatescore();//обновляем количество баллов
			updatescrn();//перерисовываем экран
		}
	}
	clrlines += cleared;//добавляем количество очищенных линий в общее количество
}

// initializes a new piece зачем фикседпоинт
void initpiece()
{
	checkclr(); // проверяем, нужно ли стереть линии
	int current;
	current = next;
	next = rand() % 7; // как только будущий кусочек становится текущим, сразу генерируем новый будущий кусочек
	switch (current)   
	{
	case 0:
		memcpy(center[0], TetrominoI[0], WIDTH * 2); // копируем в центральную часть игрового экрана текущую фигуру
		fixedpoint[0] = 1; // записываем точки фиксации для конкретной фигуры
		fixedpoint[1] = 12;
		piece = 'I'; // запоминаем символ формы фигуры
		return;
	case 1:
		memcpy(center[0], TetrominoJ[0], WIDTH * 2);
		fixedpoint[0] = 1;
		fixedpoint[1] = 10;
		piece = 'J';
		return;
	case 2:
		memcpy(center[0], TetrominoL[0], WIDTH * 2);
		fixedpoint[0] = 1;
		fixedpoint[1] = 10;
		piece = 'L';
		return;
	case 3:
		memcpy(center[0], TetrominoO[0], WIDTH * 2);
		fixedpoint[0] = 1;
		fixedpoint[1] = 10;
		piece = 'O';
		return;
	case 4:
		memcpy(center[0], TetrominoS[0], WIDTH * 2);
		fixedpoint[0] = 0;
		fixedpoint[1] = 10;
		piece = 'S';
		return;
	case 5:
		memcpy(center[0], TetrominoT[0], WIDTH * 2);
		fixedpoint[0] = 1;
		fixedpoint[1] = 10;
		piece = 'T';
		return;
	case 6:
		memcpy(center[0], TetrominoZ[0], WIDTH * 2);
		fixedpoint[0] = 0;
		fixedpoint[1] = 10;
		piece = 'Z';
		return;
	}
}

// initializes screen
void init()
{
	memcpy(left[0], "                        \0"
					"                        \0"
					"                        \0"
					"  PLAYER:               \0"
					"                        \0"
					"  LEVEL:                \0"
					"                        \0"
					"  SCORE:                \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0"
					"                        \0",
		   (HEIGHT) * (WIDTH));
	memcpy(center[0], "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<! . . . . . . . . . .!>\0"
					  "<!====================!>\0"
					  "  \\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\0",
		   (HEIGHT) * (WIDTH));
	memcpy(right[0], "                        \0"
					 "                        \0"
					 "                        \0"
					 "    : LEFT     :RIGHT   \0"
					 "         :ROTATE        \0"
					 "    : DROP     :RESET   \0"
					 "    : SHOW/HIDE NEXT    \0"
					 "    : HIDE THIS TEXT    \0"
					 "    : EXIT              \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0"
					 "                        \0",
		   (HEIGHT) * (WIDTH));
}

// updates level number on the gamescreen (on the left part)
void updatelevel()
{
	char *tmp = malloc(sizeof *tmp * 15); // 15 потому что спроектированный интерфейс настроен на такое количество символов до области с фигурками. переменная tmp становится указателем на выделенную область памяти в куче, которую можно использовать для хранения строки до 15 символов
	sprintf(tmp, "%-14d", level);		  // печатаем уровень в ТМП. sprintf - string print, в "%-14d" подставляется переменная level и всё это записывается в переменную tmp."-" это выровненное по левому краю. 14  - 14ти символьное поле. в такое поле вписывается значение типа decimal. в данном случаем вписывается значение переменной level
	memcpy(left[5] + 9, tmp, 14);		  // вписываем в левую часть игрового экрана в место для номера уровня значение tmp длинной в 14 символов
	free(tmp);							  // освобождаем память в куче
}

// simulates a game of tetris
int game()
{
	nodelay(stdscr, FALSE);							 // при FALSE - переходит режим, в котором getch() будет ждать нажатия клавиш
	init();											 // стартовый скрин копируется в массивы левыйЮ центр и правый
	setkeybind();									 // впечатывает установленные клавиши управления в инструкцию, которая лежит в правой части экрана
	clear();										 // очищаем всё в экрана
	end = 0;										 // флаг окончания игры
	score = 0;										 // счетчик баллов
	level = startlevel;								 // уровень устанавливается на тотЮ который выбрал пользователь
	clrlines = 0;									 // счетчик выстроенных горизонтальных линий игроком в игре
	memcpy(left[3] + 10, name, strlen(name));		 // вписываем имя игрока в левую часть игрового экрана
	printw("\n\n\n       Press any key to start\n"); // пишем обращение к игроку
	refresh();										 // обновления текущего содержимого окна на экране. Она принимает все изменения, сделанные с помощью функций printw(), и других, и отображает их на экране
	getch();										 // getch() ждет нажатия клавиши, потому что nodelay(stdscr, FALSE);
	updatescore();									 // вписывает актуальное количество баллов в место для количества баллов на игровом экране
	updatelevel();									 // вписывает актуальный номер уровня в место для номера уровня на игровом экране
	initpiece();									 // выводим на центральную часть срандомизированную фигуру
	updatescrn();									 // обновляем экран для отображения обновленной информации
	nodelay(stdscr, TRUE);							 // при TRUE - переходит режим, в котором getch() НЕ будет ждать нажатия клавиш
	gettimeofday(&t1, NULL);						 // в структуру t1 записывается текущее значение системного времени в секундах
	while (!usleep(DELAY))
	{
		readEncoder();
		switch (getch())
		{
		case DROP:
			if (movedown()) // если опускание фигуры закончилось успешно и без gameover
			{
				continue; // пропустить инструкции ниже
			}
			++dropped;	  // бонусные баллы
			updatescrn(); // перерисовываем экран с опущенной фигурой
			continue;	  // продолжаем игру
		case EXT:
			return 1; // выходим из функции
		case RSET:
			return 0; // выходим из функции и запускаем ее с самого начала
		case STXT:
			if (end) // если игра закончилась
			{
				continue; // пропустить инструкции ниже
			}
			showtext = !showtext; // сменить значение флага для отображения инструкции управления
			updatescrn();		  // перерисовать экран с учетом новой информации
			continue;
		case SNXT:
			if (end) // если игра закончилась
			{
				continue; // пропустить инструкции ниже
			}
			shownext = !shownext; // сменить значение флага для отображения следующей фигуры
			updatescrn();		  // перерисовать экран с учетом новой информации
			continue;
		case MOVR:
			if (end) // если игра закончилась
			{
				continue; // пропустить инструкции ниже
			}
			moveright();  // передвинуть фигуру вправо
			updatescrn(); // перерисовать экран
			continue;
		case MOVL:
			if (end) // если игра закончилась
			{
				continue; // пропустить инструкции ниже
			}
			moveleft();	  // передвинуть фигуру влево
			updatescrn(); // перерисовать экран
			continue;
		case ROTA:
			if (end || fixedpoint[0] < 2)
			{
				continue; // пропустить инструкции ниже
			}
			rotate();	  // повернуть фигуру
			updatescrn(); // перерисовать экран
			continue;
		case TPLS:
			if (!end) // если игра НЕ закончилась
			{
				continue; // пропустить инструкции ниже
			}
			toplist(); // выводим топлист (топ-20)
		}

		if (end) // если игра закончилась
		{
			gameover(); // выполняем необходимые функции по завершению игры (топлист + смена информации на экране)
			continue;	// пропустить инструкции ниже
		}
		if (clrlines == LINESFORLVLUP) // если количество очищенных линий достигло значения для перехода на новый уровень
		{
			if (level < MAXLEVEL) // если текущий уровень не максимальный
			{
				++level;	   // + уровень
				updatelevel(); // перепечатываем номер уровня в массиве left
				clrlines = 0;  // обнуляем количество очищенных линий
			}
		}
		gettimeofday(&t2, NULL);//фиксируем текущее время
		if ((((t2.tv_sec - t1.tv_sec) * 1000) + ((t2.tv_usec - t1.tv_usec) / 1000)) > DROPINTERVAL)//если прошло времени больше, чем дропинтервал
		{
			if (movedown())//если фигуру НЕ удалось успешно опустить вниз, то есть уже конец игры
			{
				continue;//пропустить инструкции ниже
			}
			updatescrn();//обновляем экран с обновленной информацией о положении фигуры
			gettimeofday(&t1, NULL);//обновляем время
		}
	}
	return 1; // выходим из игры
}
#endif